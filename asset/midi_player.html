<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Multi-track MIDI Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: #f0f2f5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #main-card {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: white;
        }

        /* --- Top Controls --- */
        .global-controls {
            padding: 12px 20px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 20;
            position: relative;
        }

        .center-controls {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        .time-display {
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-size: 14px;
            color: #666;
            min-width: 100px;
        }

        .right-controls {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        button {
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            transition: all 0.2s;
        }

        /* Icon Button (Play/Stop) */
        .icon-btn {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: #f1f3f4;
            color: #5f6368;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .icon-btn:hover {
            background: #e8eaed;
            color: #202124;
        }

        .icon-btn:disabled {
            background: #f1f3f4;
            color: #dadce0;
            cursor: not-allowed;
        }

        .icon-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        #status {
            font-weight: 500;
            color: #007bff;
            margin-left: auto;
            font-size: 13px;
        }

        .error {
            color: #dc3545 !important;
        }

        /* --- Track List Area --- */
        #tracks-scroll-area {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            /* Horizontal scroll handled by bottom bar */
            background: #fafafa;
            padding: 10px;
            position: relative;
        }

        .track-row {
            display: flex;
            height: 80px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        /* Left: Info & Controls (Fixed Width) */
        .track-sidebar {
            width: 200px;
            padding: 10px;
            border-right: 1px solid #eee;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: #f8f9fa;
            flex-shrink: 0;
            z-index: 2;
        }

        /* Vertical Scrollbar for Track */
        .track-vscroll {
            width: 12px;
            background: #f8f9fa;
            border-right: 1px solid #e1e4e8;
            overflow-y: auto;
            overflow-x: hidden;
            flex-shrink: 0;
            cursor: ns-resize;
        }

        /* Custom Scrollbar Styling */
        .track-vscroll::-webkit-scrollbar {
            width: 8px;
        }

        .track-vscroll::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .track-vscroll::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .track-vscroll::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .track-name {
            font-weight: 600;
            font-size: 13px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-controls {
            display: flex;
            gap: 6px;
        }

        .btn-mini {
            padding: 2px 0;
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            background: white;
            color: #495057;
            cursor: pointer;
            flex: 1;
            text-align: center;
        }

        .btn-mini:hover {
            background: #e9ecef;
        }

        .btn-mute.active {
            background: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        .btn-solo.active {
            background: #ffc107;
            color: black;
            border-color: #ffc107;
        }

        .btn-move-mode.active {
            background: #0d6efd;
            color: #fff;
            border-color: #0d6efd;
        }

        .track-offset {
            font-size: 11px;
            color: #6c757d;
            line-height: 1.2;
            margin-top: 4px;
        }

        .btn-reset-offset {
            padding: 2px 0;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            background: #fff;
            color: #495057;
            cursor: pointer;
            width: 100%;
            margin-top: 4px;
        }

        .btn-reset-offset:hover {
            background: #e9ecef;
        }

        .compare-track-row {
            display: flex;
            margin-bottom: 10px;
        }

        .compare-track-row.show {
            display: flex;
        }

        .compare-select {
            width: 100%;
            font-size: 11px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background: #fff;
            color: #495057;
            padding: 2px 4px;
        }

        .compare-wave {
            display: block;
            background: #fff;
        }

        /* Right: Timeline / Canvas */
        .track-timeline {
            flex: 1;
            position: relative;
            overflow: hidden;
            /* Viewport */
            cursor: pointer;
            background: #fff;
        }

        .canvas-content {
            position: absolute;
            top: 0;
            left: 0;
            /* width will be set by canvas */
            will-change: transform;
        }

        .clip-box {
            position: absolute;
            top: 0;
            border: 1px solid rgba(33, 150, 243, 0.7);
            background: rgba(33, 150, 243, 0.08);
            border-radius: 4px;
            cursor: grab;
            box-sizing: border-box;
        }

        .clip-box.dragging {
            cursor: grabbing;
            background: rgba(33, 150, 243, 0.15);
            border-color: rgba(33, 150, 243, 0.9);
        }

        .clip-box.drum {
            border-color: rgba(156, 39, 176, 0.7);
            background: rgba(156, 39, 176, 0.08);
        }

        .clip-box.drum.dragging {
            border-color: rgba(156, 39, 176, 0.9);
            background: rgba(156, 39, 176, 0.15);
        }

        canvas {
            display: block;
            /* height is determined by visualizer */
        }

        /* Playhead (in each track) */
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #ff3b30;
            z-index: 10;
            pointer-events: none;
            display: none;
        }

        /* --- Bottom Scrollbar --- */
        #timeline-scrollbar-container {
            height: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            border-top: 1px solid #ddd;
            background: #f1f1f1;
        }

        #timeline-scroll-content {
            height: 1px;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/dist/magentamusic.min.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>

<body>

    <div id="main-card">
        <div class="global-controls">
            <span class="time-display" id="timeLabel">00:00 / 00:00</span>

            <div class="center-controls">
                <button id="playBtn" class="icon-btn" disabled title="Êí≠Êîæ">
                    <svg viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                </button>
                <button id="stopBtn" class="icon-btn" disabled title="ÂÅúÊ≠¢">
                    <svg viewBox="0 0 24 24">
                        <path d="M6 6h12v12H6z" />
                    </svg>
                </button>
            </div>

            <div class="right-controls">
                <button id="moveModeBtn" class="btn-mini btn-move-mode" style="width: 96px;" disabled>ÁßªÂä®Ê®°Âºè:ÂÖ≥</button>
                <button id="exportBtn" class="btn-mini" style="width: 92px;" disabled>‰øùÂ≠òMIDI</button>
                <div id="status">Á≠âÂæÖÂä†ËΩΩ MIDI...</div>
            </div>
        </div>

        <div id="timeline-scrollbar-container">
            <div id="timeline-scroll-content"></div>
        </div>

        <div id="tracks-scroll-area">
            <div id="compare-track-row" class="track-row compare-track-row">
                <div class="track-sidebar">
                    <div class="track-name">üéß WAV ÂØπÁÖß</div>
                    <div class="track-controls">
                        <button id="compareMuteBtn" class="btn-mini btn-mute">M</button>
                        <button id="compareSoloBtn" class="btn-mini btn-solo">S</button>
                    </div>
                    <select id="compareWavSelect" class="compare-select"></select>
                </div>
                <div class="track-vscroll" style="cursor: default;">
                    <div class="vscroll-spacer" style="height: 56px;"></div>
                </div>
                <div id="compareTimeline" class="track-timeline">
                    <div id="compareCanvasContent" class="canvas-content">
                        <canvas id="compareWaveCanvas" class="compare-wave" height="56"></canvas>
                    </div>
                    <div id="comparePlayhead" class="playhead"></div>
                </div>
            </div>

            <div id="tracks-container">
                <div style="padding: 40px; text-align: center; color: #999;">
                    ËØ∑‰ªéÂ∑¶‰æßÊñá‰ª∂Ê†ëÈÄâÊã© MIDI Êñá‰ª∂...
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        let player = null;
        let currentSequence = null; // The full original sequence
        let tracks = []; // Array of track objects

        let isPlaying = false;
        let animationId = null;
        let startTime = 0;
        let pauseOffset = 0;
        let totalDuration = 0;
        let totalDurationForDisplay = 0;
        let exportBridge = null;
        let defaultExportFilename = "export_‰øÆÊîπ.mid";
        let isMoveMode = false;
        let compareAudioEl = null;
        let compareAudioUrl = null;
        let compareAudioDuration = 0;
        let compareWaveReady = false;
        let compareTrackLoaded = false;
        let compareMuted = false;
        let compareSoloed = false;

        const PIXELS_PER_STEP = 50;
        const DRAG_PIXEL_THRESHOLD = 3;

        const compareTrackRow = document.getElementById('compare-track-row');
        const compareWavSelect = document.getElementById('compareWavSelect');
        const compareMuteBtn = document.getElementById('compareMuteBtn');
        const compareSoloBtn = document.getElementById('compareSoloBtn');
        const compareTimeline = document.getElementById('compareTimeline');
        const compareCanvasContent = document.getElementById('compareCanvasContent');
        const compareWaveCanvas = document.getElementById('compareWaveCanvas');
        const comparePlayhead = document.getElementById('comparePlayhead');

        // GM Instruments Map
        const GM_INSTRUMENTS = {
            0: "Acoustic Grand Piano", 19: "Church Organ", 24: "Acoustic Guitar (Nylon)",
            40: "Violin", 48: "String Ensemble 1", 56: "Trumpet", 66: "Tenor Sax",
            73: "Flute", 128: "Drums"
        };

        // --- Initialization ---
        async function init() {
            const status = document.getElementById('status');
            try {
                player = new mm.SoundFontPlayer('https://storage.googleapis.com/magentadata/js/soundfonts/sgm_plus');
                console.log("Player initialized");

                if (window.qt && window.QWebChannel) {
                    new QWebChannel(qt.webChannelTransport, (channel) => {
                        exportBridge = channel.objects.midiExportBridge || null;
                    });
                }
            } catch (e) {
                status.innerText = "ÂàùÂßãÂåñÂ§±Ë¥•: " + e.message;
                status.classList.add('error');
            }

            // Sync Scroll
            const scrollBar = document.getElementById('timeline-scrollbar-container');
            scrollBar.addEventListener('scroll', () => {
                updateTrackViewportTransforms();
                const currentShown = isPlaying
                    ? Math.min(mm.Player.tone.context.currentTime - startTime, totalDurationForDisplay)
                    : Math.min(pauseOffset, totalDurationForDisplay);
                updatePlayheads(currentShown);
            });

            compareWavSelect.addEventListener('change', async () => {
                const name = compareWavSelect.value;
                if (!name) return;
                await loadCompareWavByName(name);
            });

            compareMuteBtn.addEventListener('click', () => {
                compareMuted = !compareMuted;
                compareMuteBtn.classList.toggle('active', compareMuted);
                if (compareMuted) {
                    pauseCompareAudio();
                } else if (isPlaying) {
                    const current = Math.min(mm.Player.tone.context.currentTime - startTime, totalDurationForDisplay);
                    startCompareAudio(current);
                }
            });

            compareSoloBtn.addEventListener('click', () => {
                compareSoloed = !compareSoloed;
                compareSoloBtn.classList.toggle('active', compareSoloed);
                if (isPlaying) {
                    const current = Math.min(mm.Player.tone.context.currentTime - startTime, totalDurationForDisplay);
                    startPlayback(current);
                }
            });

            compareTimeline.addEventListener('click', (e) => {
                if (!currentSequence) return;

                const rect = compareTimeline.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const scrollLeft = getTimelineScrollLeft();
                const absoluteX = clickX + scrollLeft;
                const targetTime = absoluteX / PIXELS_PER_STEP;

                if (targetTime >= 0 && targetTime <= totalDurationForDisplay) {
                    seekTo(targetTime);
                }
            });
        }

        window.setExportDefaultFilename = function (filename) {
            if (!filename || typeof filename !== 'string') return;
            defaultExportFilename = filename;
        };

        // --- Core Logic ---

        function processTracks(seq) {
            const map = new Map();

            seq.notes.forEach(n => {
                const instId = n.instrument;
                const program = n.program;
                const isDrum = n.isDrum;

                // Group by Instrument (Channel) AND Program to separate different sounds on same channel
                // or same sound on different channels.
                const key = `i${instId}_p${program}_d${isDrum}`;

                if (!map.has(key)) {
                    let baseName = isDrum ? "Drums" : (GM_INSTRUMENTS[program] || `Instrument #${program}`);
                    let icon = isDrum ? "ü•Å" : "üéπ";
                    // Display Channel info
                    let name = `${icon} ${baseName} (Ch.${instId})`;

                    map.set(key, {
                        id: key,
                        name: name,
                        notes: [],
                        program: program,
                        isDrum: isDrum,
                        muted: false,
                        soloed: false,
                        instId: instId,
                        offsetSeconds: 0,
                        minStart: Number.POSITIVE_INFINITY,
                        maxEnd: 0,
                        dom: null
                    });
                }
                const track = map.get(key);
                track.notes.push(n);
                if (n.startTime < track.minStart) track.minStart = n.startTime;
                if (n.endTime > track.maxEnd) track.maxEnd = n.endTime;
            });

            // Sort by Channel then Program
            const trackList = Array.from(map.values()).sort((a, b) => {
                if (a.instId !== b.instId) return a.instId - b.instId;
                return a.program - b.program;
            });

            trackList.forEach(track => {
                if (!Number.isFinite(track.minStart)) {
                    track.minStart = 0;
                    track.maxEnd = 0;
                }
                track.clipDuration = Math.max(track.maxEnd - track.minStart, 0.001);
                track.notes = track.notes.map(n => ({ ...n }));
            });

            return trackList;
        }

        function renderTracks() {
            const container = document.getElementById('tracks-container');
            container.innerHTML = '';

            tracks.forEach(t => {
                const row = document.createElement('div');
                row.className = 'track-row';

                row.innerHTML = `
                    <div class="track-sidebar">
                        <div class="track-name" title="${t.name}">${t.name}</div>
                        <div class="track-controls">
                            <button class="btn-mini btn-mute">M</button>
                            <button class="btn-mini btn-solo">S</button>
                        </div>
                        <div class="track-offset">ÂÅèÁßª: +0.00s</div>
                        <button class="btn-reset-offset">ÈáçÁΩÆÂÅèÁßª</button>
                    </div>
                    <div class="track-vscroll">
                        <div class="vscroll-spacer"></div>
                    </div>
                    <div class="track-timeline">
                        <div class="canvas-content">
                            <div class="clip-box ${t.isDrum ? 'drum' : ''}">
                                <canvas></canvas>
                            </div>
                        </div>
                        <div class="playhead"></div>
                    </div>
                `;

                container.appendChild(row);

                // Store DOM refs
                t.dom = {
                    row: row,
                    canvas: row.querySelector('canvas'),
                    clipBox: row.querySelector('.clip-box'),
                    canvasContent: row.querySelector('.canvas-content'),
                    playhead: row.querySelector('.playhead'),
                    muteBtn: row.querySelector('.btn-mute'),
                    soloBtn: row.querySelector('.btn-solo'),
                    resetOffsetBtn: row.querySelector('.btn-reset-offset'),
                    offsetLabel: row.querySelector('.track-offset'),
                    timeline: row.querySelector('.track-timeline'),
                    vscroll: row.querySelector('.track-vscroll'),
                    vscrollSpacer: row.querySelector('.vscroll-spacer')
                };

                // Bind Events
                t.dom.muteBtn.onclick = () => toggleMute(t);
                t.dom.soloBtn.onclick = () => toggleSolo(t);
                t.dom.resetOffsetBtn.onclick = () => resetTrackOffset(t);
                t.dom.timeline.onclick = (e) => handleSeek(e, t);
                bindTrackDrag(t);
                t.dom.muteBtn.classList.toggle('active', !!t.muted);
                t.dom.soloBtn.classList.toggle('active', !!t.soloed);

                // Vertical Scroll Sync
                t.dom.vscroll.onscroll = () => {
                    applyTrackViewportTransform(t);
                };

                // Visualize
                const trackSeq = {
                    notes: t.notes.map(n => ({
                        ...n,
                        startTime: n.startTime - t.minStart,
                        endTime: n.endTime - t.minStart
                    })),
                    totalTime: t.clipDuration
                };

                // Use PianoRollCanvasVisualizer
                t.visualizer = new mm.PianoRollCanvasVisualizer(trackSeq, t.dom.canvas, {
                    noteHeight: 6,
                    pixelsPerTimeStep: PIXELS_PER_STEP,
                    noteRGB: t.isDrum ? '156, 39, 176' : '33, 150, 243',
                    activeNoteRGB: '255, 87, 34'
                });

                // After visualizer renders (it's synchronous usually), update scroll spacer
                // We need to wait for the canvas to be sized.
                // Magenta visualizer resizes canvas immediately in constructor.
                const canvasHeight = t.dom.canvas.height;
                t.dom.clipBox.style.height = canvasHeight + 'px';
                t.dom.vscrollSpacer.style.height = canvasHeight + 'px';
                t.dom.clipBox.style.width = (t.clipDuration * PIXELS_PER_STEP) + 'px';
                updateTrackOffsetUI(t);
                updateTrackClipPosition(t);
                applyTrackViewportTransform(t);

                // Center the view initially if it's too tall? 
                // Or just start at top. Let's start at top.
                // If we want to center on notes, we'd need to calculate average pitch.
            });

            updateTimelineMetrics();
        }

        function getTimelineScrollLeft() {
            const scrollBar = document.getElementById('timeline-scrollbar-container');
            return scrollBar.scrollLeft;
        }

        function applyTrackViewportTransform(track) {
            const left = getTimelineScrollLeft();
            const top = track.dom.vscroll.scrollTop;
            track.dom.canvasContent.style.transform = `translate(${-left}px, -${top}px)`;
        }

        function updateTrackViewportTransforms() {
            tracks.forEach(t => applyTrackViewportTransform(t));
            applyCompareViewportTransform();
        }

        function applyCompareViewportTransform() {
            const left = getTimelineScrollLeft();
            compareCanvasContent.style.transform = `translate(${-left}px, 0px)`;
        }

        async function ensureCompareTrackLoaded() {
            if (compareTrackLoaded) return;
            if (!exportBridge || typeof exportBridge.getCompareWavList !== 'function') {
                statusLabel.innerText = 'Êú™ËøûÊé•Âà∞ÂàÜËΩ®WAVÊ°•Êé•';
                return;
            }

            const payloadText = await new Promise((resolve) => {
                exportBridge.getCompareWavList(resolve);
            });

            let payload = {};
            try {
                payload = JSON.parse(payloadText || '{}');
            } catch {
                payload = {};
            }

            const files = Array.isArray(payload.files) ? payload.files : [];
            compareWavSelect.innerHTML = '';

            if (!files.length) {
                statusLabel.innerText = 'Êú™ÊâæÂà∞ÂàÜËΩ®WAVÊñá‰ª∂';
                compareTrackLoaded = true;
                return;
            }

            files.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.innerText = name;
                compareWavSelect.appendChild(option);
            });

            const defaultName = payload.default && files.includes(payload.default)
                ? payload.default
                : files[0];
            compareWavSelect.value = defaultName;
            compareTrackLoaded = true;
            await loadCompareWavByName(defaultName);
        }

        async function loadCompareWavByName(filename) {
            if (!exportBridge || typeof exportBridge.getCompareWavBase64 !== 'function') return;

            statusLabel.innerText = `Âä†ËΩΩÂØπÁÖßWAV: ${filename}`;
            const payloadText = await new Promise((resolve) => {
                exportBridge.getCompareWavBase64(filename, resolve);
            });

            let payload = {};
            try {
                payload = JSON.parse(payloadText || '{}');
            } catch {
                payload = {};
            }

            if (!payload.ok || !payload.data) {
                statusLabel.innerText = `ÂØπÁÖßWAVÂä†ËΩΩÂ§±Ë¥•: ${payload.error || 'Êú™Áü•ÈîôËØØ'}`;
                return;
            }

            const wavBytes = base64ToUint8Array(payload.data);
            const wavBlob = new Blob([wavBytes], { type: payload.mime || 'audio/wav' });
            const url = URL.createObjectURL(wavBlob);

            if (compareAudioUrl) {
                URL.revokeObjectURL(compareAudioUrl);
            }
            compareAudioUrl = url;

            if (!compareAudioEl) {
                compareAudioEl = new Audio();
                compareAudioEl.preload = 'auto';
            }

            compareAudioEl.src = compareAudioUrl;
            compareAudioEl.currentTime = Math.min(pauseOffset, compareAudioEl.duration || pauseOffset || 0);

            await decodeAndRenderCompareWave(wavBytes);

            if (isMoveMode && isPlaying) {
                startCompareAudio(mm.Player.tone.context.currentTime - startTime);
            }
        }

        async function decodeAndRenderCompareWave(wavBytes) {
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) {
                compareWaveReady = false;
                compareAudioDuration = 0;
                statusLabel.innerText = 'ÂΩìÂâçÁéØÂ¢É‰∏çÊîØÊåÅÊ≥¢ÂΩ¢Ëß£Á†Å';
                return;
            }

            const ctx = new AudioCtx();
            const arr = wavBytes.buffer.slice(wavBytes.byteOffset, wavBytes.byteOffset + wavBytes.byteLength);

            try {
                const audioBuffer = await ctx.decodeAudioData(arr.slice(0));
                compareAudioDuration = audioBuffer.duration || 0;
                renderCompareWave(audioBuffer);
                compareWaveReady = true;
                updateTimelineMetrics();
                updateTrackViewportTransforms();
            } catch (e) {
                compareWaveReady = false;
                compareAudioDuration = 0;
                statusLabel.innerText = `Ê≥¢ÂΩ¢Ëß£Á†ÅÂ§±Ë¥•: ${e.message || e}`;
            } finally {
                ctx.close();
            }
        }

        function renderCompareWave(audioBuffer) {
            const duration = audioBuffer.duration || 0;
            const width = Math.max(1, Math.ceil(duration * PIXELS_PER_STEP));
            const height = compareWaveCanvas.height || 56;

            compareWaveCanvas.width = width;
            compareWaveCanvas.height = height;

            const context = compareWaveCanvas.getContext('2d');
            context.clearRect(0, 0, width, height);
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, width, height);

            const channelData = audioBuffer.getChannelData(0);
            const step = Math.max(1, Math.floor(channelData.length / width));
            const half = height / 2;

            context.strokeStyle = '#6c757d';
            context.lineWidth = 1;
            context.beginPath();
            context.moveTo(0, half);
            context.lineTo(width, half);
            context.stroke();

            context.strokeStyle = '#198754';
            context.beginPath();
            for (let x = 0; x < width; x++) {
                const start = x * step;
                const end = Math.min(channelData.length, start + step);
                let min = 1;
                let max = -1;
                for (let i = start; i < end; i++) {
                    const v = channelData[i];
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
                context.moveTo(x, half + min * half * 0.9);
                context.lineTo(x, half + max * half * 0.9);
            }
            context.stroke();
        }

        function startCompareAudio(offsetSeconds = 0) {
            if (!compareAudioEl || compareMuted) return;
            try {
                compareAudioEl.currentTime = Math.max(0, Math.min(offsetSeconds, compareAudioEl.duration || offsetSeconds));
                compareAudioEl.play().catch(() => { });
            } catch {
            }
        }

        function pauseCompareAudio() {
            if (!compareAudioEl) return;
            compareAudioEl.pause();
        }

        function stopCompareAudio() {
            if (!compareAudioEl) return;
            compareAudioEl.pause();
            compareAudioEl.currentTime = 0;
        }

        function setMoveMode(enabled) {
            isMoveMode = !!enabled;
            moveModeBtn.classList.toggle('active', isMoveMode);
            moveModeBtn.innerText = isMoveMode ? 'ÁßªÂä®Ê®°Âºè:ÂºÄ' : 'ÁßªÂä®Ê®°Âºè:ÂÖ≥';
            tracks.forEach(t => {
                if (!t.dom || !t.dom.clipBox) return;
                t.dom.clipBox.style.cursor = isMoveMode ? 'grab' : 'default';
            });

            if (isPlaying) {
                const current = Math.min(mm.Player.tone.context.currentTime - startTime, totalDurationForDisplay);
                if (compareMuted) {
                    pauseCompareAudio();
                } else {
                    startCompareAudio(current);
                }
            }

            updateTimelineMetrics();
            updateTrackViewportTransforms();
            updatePlayheads(Math.min(pauseOffset, totalDurationForDisplay));
        }

        function bindTrackDrag(track) {
            const clipBox = track.dom.clipBox;
            let dragging = false;
            let startX = 0;
            let startOffset = 0;
            let playedBeforeDrag = false;
            let moved = false;

            clipBox.addEventListener('pointerdown', (e) => {
                if (e.button !== 0) return;
                if (!isMoveMode) return;
                dragging = true;
                moved = false;
                startX = e.clientX;
                startOffset = track.offsetSeconds || 0;
                playedBeforeDrag = isPlaying;
                if (isPlaying) pausePlayback();
                clipBox.classList.add('dragging');
                clipBox.setPointerCapture(e.pointerId);
                e.preventDefault();
                e.stopPropagation();
            });

            clipBox.addEventListener('pointermove', (e) => {
                if (!dragging) return;
                const deltaX = e.clientX - startX;
                if (Math.abs(deltaX) > DRAG_PIXEL_THRESHOLD) moved = true;
                const deltaSeconds = deltaX / PIXELS_PER_STEP;
                const minOffset = -track.minStart;
                const newOffset = Math.max(minOffset, startOffset + deltaSeconds);
                setTrackOffset(track, newOffset, true);
            });

            const stopDrag = () => {
                if (!dragging) return;
                dragging = false;
                clipBox.classList.remove('dragging');
                track.suppressNextSeekClick = moved;
                if (playedBeforeDrag) startPlayback(pauseOffset);
            };

            clipBox.addEventListener('pointerup', stopDrag);
            clipBox.addEventListener('pointercancel', stopDrag);
        }

        function setTrackOffset(track, offsetSeconds, fromDrag = false) {
            const rounded = Math.round(offsetSeconds * 1000) / 1000;
            track.offsetSeconds = rounded;
            updateTrackOffsetUI(track);
            updateTrackClipPosition(track);
            updateTimelineMetrics();
            if (!fromDrag && isPlaying) restartPlayback();
        }

        function resetTrackOffset(track) {
            setTrackOffset(track, 0);
        }

        function resetAllTrackOffsets() {
            tracks.forEach(track => {
                track.offsetSeconds = 0;
                updateTrackOffsetUI(track);
                updateTrackClipPosition(track);
            });
            updateTimelineMetrics();
            updateTrackViewportTransforms();
            updatePlayheads(Math.min(pauseOffset, totalDurationForDisplay));
        }

        function commitOffsetsToCurrentState() {
            const shiftedSeq = normalizeSequenceForExport(getShiftedFullSequence());
            const oldState = new Map();
            tracks.forEach(t => {
                oldState.set(t.id, { muted: !!t.muted, soloed: !!t.soloed });
            });

            currentSequence = JSON.parse(JSON.stringify(shiftedSeq));
            tracks = processTracks(currentSequence);
            tracks.forEach(t => {
                const state = oldState.get(t.id);
                if (state) {
                    t.muted = state.muted;
                    t.soloed = state.soloed;
                }
            });

            renderTracks();
            pauseOffset = Math.min(pauseOffset, totalDurationForDisplay);
            tracks.forEach(t => {
                t.dom.playhead.style.display = 'block';
            });
            updatePlayheads(pauseOffset);
            updateTimeLabel(pauseOffset);
        }

        function updateTrackOffsetUI(track) {
            const sign = track.offsetSeconds >= 0 ? '+' : '';
            track.dom.offsetLabel.innerText = `ÂÅèÁßª: ${sign}${track.offsetSeconds.toFixed(2)}s`;
        }

        function updateTrackClipPosition(track) {
            const leftSeconds = track.minStart + track.offsetSeconds;
            track.dom.clipBox.style.left = (leftSeconds * PIXELS_PER_STEP) + 'px';
        }

        function getTrackShiftedNotes(track) {
            return track.notes.map(n => ({
                ...n,
                startTime: n.startTime + track.offsetSeconds,
                endTime: n.endTime + track.offsetSeconds
            }));
        }

        function updateTimelineMetrics() {
            let maxEnd = 0;
            tracks.forEach(t => {
                const end = t.maxEnd + t.offsetSeconds;
                if (end > maxEnd) maxEnd = end;
            });
            if (compareWaveReady && compareAudioDuration > maxEnd) {
                maxEnd = compareAudioDuration;
            }
            totalDuration = Math.max(maxEnd, 0);
            totalDurationForDisplay = totalDuration;

            const scrollContent = document.getElementById('timeline-scroll-content');
            const width = Math.max(totalDuration * PIXELS_PER_STEP + 120, 800);
            scrollContent.style.width = width + 'px';

            const currentShown = Math.min(pauseOffset, totalDurationForDisplay);
            updateTimeLabel(currentShown);
            updatePlayheads(currentShown);
        }

        function toggleMute(track) {
            track.muted = !track.muted;
            track.dom.muteBtn.classList.toggle('active', track.muted);

            // If solo is active on this track, mute overrides? 
            // Usually Solo overrides Mute. 
            // Logic: If any Solo, only Soloed play. Mute is ignored on Soloed tracks?
            // Let's stick to simple logic:
            // Playable = (AnySolo ? (t.solo) : (!t.mute))

            if (isPlaying) restartPlayback();
        }

        function toggleSolo(track) {
            track.soloed = !track.soloed;
            track.dom.soloBtn.classList.toggle('active', track.soloed);

            // Update UI for other tracks (optional visual feedback)
            if (isPlaying) restartPlayback();
        }

        function getPlayableSequence() {
            const anySolo = tracks.some(t => t.soloed);
            let activeTracks = [];

            if (anySolo) {
                activeTracks = tracks.filter(t => t.soloed);
            } else {
                activeTracks = tracks.filter(t => !t.muted);
            }

            const notes = [];
            activeTracks.forEach(t => notes.push(...getTrackShiftedNotes(t)));
            notes.sort((a, b) => a.startTime - b.startTime);

            const maxEnd = notes.reduce((acc, n) => Math.max(acc, n.endTime), 0);

            // Return a new sequence object
            return {
                notes: notes,
                totalTime: maxEnd,
                tempos: currentSequence.tempos,
                timeSignatures: currentSequence.timeSignatures
            };
        }

        // --- Playback Control ---

        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const moveModeBtn = document.getElementById('moveModeBtn');
        const exportBtn = document.getElementById('exportBtn');
        const timeLabel = document.getElementById('timeLabel');
        const statusLabel = document.getElementById('status');

        playBtn.addEventListener('click', () => {
            if (!currentSequence) return;
            if (isPlaying) pausePlayback();
            else startPlayback(pauseOffset);
        });

        stopBtn.addEventListener('click', () => {
            stopPlayback();
        });

        moveModeBtn.addEventListener('click', () => {
            setMoveMode(!isMoveMode);
        });

        exportBtn.addEventListener('click', async () => {
            await exportShiftedMidi();
        });

        function handleSeek(e, track) {
            if (!currentSequence) return;
            if (track.suppressNextSeekClick) {
                track.suppressNextSeekClick = false;
                return;
            }
            const timelineEl = track.dom.timeline;

            // Calculate time based on click position + scroll
            const rect = timelineEl.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const scrollLeft = getTimelineScrollLeft();
            const absoluteX = clickX + scrollLeft;

            const targetTime = absoluteX / PIXELS_PER_STEP;

            if (targetTime >= 0 && targetTime <= totalDurationForDisplay) {
                seekTo(targetTime);
            }
        }

        function seekTo(seconds) {
            const wasPlaying = isPlaying;
            if (wasPlaying) pausePlayback(); // Pause temporarily

            pauseOffset = seconds;
            if (!wasPlaying && compareAudioEl) {
                try {
                    compareAudioEl.currentTime = Math.max(0, Math.min(seconds, compareAudioEl.duration || seconds));
                } catch {
                }
            }
            updatePlayheads(seconds);
            updateTimeLabel(seconds);

            if (wasPlaying) startPlayback(seconds);
        }

        function restartPlayback() {
            // Called when Mute/Solo changes
            const current = Math.min(mm.Player.tone.context.currentTime - startTime, totalDurationForDisplay);
            startPlayback(current);
        }

        async function startPlayback(offsetSeconds = 0) {
            if (player.isPlaying()) player.stop();

            const midiEnabled = !compareSoloed;
            const compareEnabled = compareWaveReady && !!compareAudioEl && !compareMuted;

            let playSeq = null;
            if (midiEnabled) {
                const seq = getPlayableSequence();
                playSeq = trimSequence(seq, offsetSeconds);
            }

            if ((!playSeq || !playSeq.notes.length || playSeq.totalTime <= 0) && !compareEnabled) {
                statusLabel.innerText = "Êó†ÂèØÊí≠ÊîæÈü≥Á¨¶";
                isPlaying = false;
                return;
            }

            isPlaying = true;
            playBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
            playBtn.title = "ÊöÇÂÅú";
            statusLabel.innerText = "Êí≠Êîæ‰∏≠...";

            if (playSeq && playSeq.notes.length && playSeq.totalTime > 0) {
                player.start(playSeq).then(() => {
                    if (isPlaying && !compareEnabled) {
                        stopPlayback();
                    }
                });
            }

            if (compareEnabled) {
                startCompareAudio(offsetSeconds);
            }

            startTime = mm.Player.tone.context.currentTime - offsetSeconds;

            // Show playheads
            tracks.forEach(t => t.dom.playhead.style.display = 'block');

            animate();
        }

        function pausePlayback() {
            if (player.isPlaying()) player.stop();
            pauseCompareAudio();
            isPlaying = false;
            cancelAnimationFrame(animationId);
            playBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
            playBtn.title = "Êí≠Êîæ";
            statusLabel.innerText = "Â∑≤ÊöÇÂÅú";

            pauseOffset = mm.Player.tone.context.currentTime - startTime;
        }

        function stopPlayback() {
            if (player.isPlaying()) player.stop();
            stopCompareAudio();
            isPlaying = false;
            cancelAnimationFrame(animationId);
            playBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
            playBtn.title = "Êí≠Êîæ";
            statusLabel.innerText = "Â∞±Áª™";

            pauseOffset = 0;
            updatePlayheads(0);
            updateTimeLabel(0);

            // ‰øùÊåÅÊí≠ÊîæÂ§¥ÊòæÁ§∫Âú®Ëµ∑Âßã‰ΩçÁΩÆ
            // tracks.forEach(t => t.dom.playhead.style.display = 'none');

            // Reset scroll? No, keep it.
        }

        function animate() {
            if (!isPlaying) return;

            const now = mm.Player.tone.context.currentTime;
            const currentSec = now - startTime;

            if (currentSec > totalDuration) {
                // Wait for player promise to resolve
                return;
            }

            updatePlayheads(currentSec);
            updateTimeLabel(currentSec);
            autoScroll(currentSec);

            animationId = requestAnimationFrame(animate);
        }

        function updatePlayheads(seconds) {
            const x = seconds * PIXELS_PER_STEP;
            const scrollLeft = getTimelineScrollLeft();
            tracks.forEach(t => {
                t.dom.playhead.style.left = (x - scrollLeft) + 'px';
            });
            comparePlayhead.style.display = 'block';
            comparePlayhead.style.left = (x - scrollLeft) + 'px';
        }

        function autoScroll(seconds) {
            const x = seconds * PIXELS_PER_STEP;
            const scrollBar = document.getElementById('timeline-scrollbar-container');
            const width = scrollBar.clientWidth;
            const scroll = scrollBar.scrollLeft;

            // Auto scroll if playhead reaches right edge
            if (x > scroll + width - 50) {
                scrollBar.scrollLeft = x - 50;
            }
        }

        function updateTimeLabel(current) {
            const fmt = t => {
                const m = Math.floor(t / 60);
                const s = Math.floor(t % 60);
                return `${m < 10 ? '0' + m : m}:${s < 10 ? '0' + s : s}`;
            };
            timeLabel.innerText = `${fmt(current)} / ${fmt(totalDurationForDisplay)}`;
        }

        // --- Helpers ---
        function trimSequence(seq, startTime) {
            const newSeq = JSON.parse(JSON.stringify(seq));
            newSeq.notes = newSeq.notes.filter(n => n.startTime >= startTime);
            newSeq.notes.forEach(n => {
                n.startTime -= startTime;
                n.endTime -= startTime;
            });
            newSeq.totalTime = Math.max(newSeq.totalTime - startTime, 0);
            return newSeq;
        }

        function getShiftedFullSequence() {
            const seq = JSON.parse(JSON.stringify(currentSequence));
            const shiftedNotes = [];
            tracks.forEach(track => {
                shiftedNotes.push(...getTrackShiftedNotes(track));
            });
            shiftedNotes.sort((a, b) => a.startTime - b.startTime);

            const maxEnd = shiftedNotes.reduce((acc, n) => Math.max(acc, n.endTime), 0);
            seq.notes = shiftedNotes;
            seq.totalTime = maxEnd;
            return seq;
        }

        function normalizeSequenceForExport(seq) {
            if (!seq || typeof seq !== 'object') {
                return {
                    notes: [],
                    tempos: [{ time: 0, qpm: 120 }],
                    timeSignatures: [],
                    keySignatures: [],
                    controlChanges: [],
                    pitchBends: [],
                    textAnnotations: [],
                    totalTime: 0,
                    ticksPerQuarter: 220
                };
            }

            if (!Array.isArray(seq.notes)) seq.notes = [];
            if (!Array.isArray(seq.tempos)) seq.tempos = [];
            if (!Array.isArray(seq.timeSignatures)) seq.timeSignatures = [];
            if (!Array.isArray(seq.keySignatures)) seq.keySignatures = [];
            if (!Array.isArray(seq.controlChanges)) seq.controlChanges = [];
            if (!Array.isArray(seq.pitchBends)) seq.pitchBends = [];
            if (!Array.isArray(seq.textAnnotations)) seq.textAnnotations = [];

            if (seq.tempos.length === 0) {
                seq.tempos.push({ time: 0, qpm: 120 });
            }

            if (typeof seq.ticksPerQuarter !== 'number' || !Number.isFinite(seq.ticksPerQuarter) || seq.ticksPerQuarter <= 0) {
                seq.ticksPerQuarter = 220;
            }

            seq.notes = seq.notes
                .filter(n => n && typeof n.startTime === 'number' && typeof n.endTime === 'number')
                .map(n => ({
                    ...n,
                    startTime: Math.max(0, n.startTime),
                    endTime: Math.max(n.startTime, n.endTime),
                    velocity: typeof n.velocity === 'number' ? n.velocity : 80,
                    pitch: typeof n.pitch === 'number' ? n.pitch : 60,
                    instrument: typeof n.instrument === 'number' ? n.instrument : 0,
                    program: typeof n.program === 'number' ? n.program : 0,
                    isDrum: !!n.isDrum
                }));

            seq.totalTime = seq.notes.reduce((acc, n) => Math.max(acc, n.endTime), 0);
            return seq;
        }

        async function exportShiftedMidi() {
            if (!currentSequence || !tracks.length) return;
            try {
                statusLabel.innerText = 'Ê≠£Âú®‰øùÂ≠ò MIDI...';
                const seq = normalizeSequenceForExport(getShiftedFullSequence());
                const midiBytes = await Promise.resolve(mm.sequenceProtoToMidi(seq));

                if (exportBridge && typeof exportBridge.saveMidiBase64 === 'function') {
                    let binary = '';
                    const chunkSize = 0x8000;
                    for (let i = 0; i < midiBytes.length; i += chunkSize) {
                        const chunk = midiBytes.subarray(i, i + chunkSize);
                        binary += String.fromCharCode.apply(null, chunk);
                    }
                    const midiBase64 = btoa(binary);

                    const result = await new Promise((resolve) => {
                        if (typeof exportBridge.saveMidiToCurrentPath === 'function') {
                            exportBridge.saveMidiToCurrentPath(midiBase64, resolve);
                        } else {
                            exportBridge.saveMidiBase64(midiBase64, defaultExportFilename, resolve);
                        }
                    });

                    if (result === 'CANCELLED') {
                        statusLabel.innerText = 'Â∑≤ÂèñÊ∂à‰øùÂ≠ò';
                        return;
                    }
                    if (typeof result === 'string' && result.startsWith('ERROR:')) {
                        throw new Error(result.replace('ERROR:', '').trim());
                    }

                    commitOffsetsToCurrentState();
                    statusLabel.innerText = '‰øùÂ≠òÂÆåÊàê';
                    return;
                }

                const blob = new Blob([midiBytes], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = defaultExportFilename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                commitOffsetsToCurrentState();
                statusLabel.innerText = '‰øùÂ≠òÂÆåÊàê(ÊµèËßàÂô®‰∏ãËΩΩ)';
            } catch (e) {
                console.error(e);
                statusLabel.innerText = '‰øùÂ≠òÂ§±Ë¥•: ' + e.message;
                statusLabel.classList.add('error');
            }
        }

        function base64ToUint8Array(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
        }

        // --- Python Êé•Âè£ ---
        window.loadMidiContent = async function (base64Data) {
            statusLabel.innerText = "Ê≠£Âú®Ëß£Êûê MIDI...";
            playBtn.disabled = true;
            stopBtn.disabled = true;

            try {
                const midiBytes = base64ToUint8Array(base64Data);
                const seq = await mm.midiToSequenceProto(midiBytes);
                currentSequence = seq;
                totalDuration = seq.totalTime;
                totalDurationForDisplay = seq.totalTime;

                // Process Tracks
                tracks = processTracks(seq);
                renderTracks();

                // Reset
                stopPlayback();

                statusLabel.innerText = "Ê≠£Âú®Âä†ËΩΩÈááÊ†∑...";
                await player.loadSamples(seq);

                statusLabel.innerText = "ÂáÜÂ§áÂ∞±Áª™";
                playBtn.disabled = false;
                stopBtn.disabled = false;
                moveModeBtn.disabled = false;
                exportBtn.disabled = false;
                compareTrackLoaded = false;
                await ensureCompareTrackLoaded();
                setMoveMode(false);

                // ÊòæÁ§∫Êí≠ÊîæÂ§¥Âú®Ëµ∑Âßã‰ΩçÁΩÆ
                tracks.forEach(t => {
                    t.dom.playhead.style.display = 'block';
                    t.dom.playhead.style.left = '0px';
                });
                updateTimeLabel(0);

                return "Success";
            } catch (e) {
                console.error(e);
                statusLabel.innerText = "ÈîôËØØ: " + e.message;
                statusLabel.classList.add('error');
                moveModeBtn.disabled = true;
                exportBtn.disabled = true;
            }
        }

        window.addEventListener('load', init);
    </script>
</body>

</html>